-----
### DevOps에서 가장 중요한 것 (개발 → 빌드 → 실행 파일)
-----
<div align="center">
<img src="https://github.com/user-attachments/assets/c4ce4f11-a19f-4a5f-8824-c786786ddf97" />
</div>

1. 개발 환경은 통상 PC라고 가정
   - 개발 툴 : IntelliJ (이를 이용해 코드를 작성하고, 빌드를 쉽게 실행 가능)
   - 개발하기 위한 툴킷 : OpenJDK 지정 (Spring Framework를 사용해 애플리케이션 동작)
   - 코드를 실행 가능한 파일로 만들기 위해 빌드(Build) 수행 - Gradle로 빌드를 하지만, 빌드 과정에서 소스를 컴파일 하는 부분은 OpenJDK 사용하여 jar 파일 생성 (이 파일이 OpenJDK에 있는 JVM 위에서 실행)
   - 즉, 빌드하고 파일을 실행하는데 OpenJDK가 항상 필요

2. DevOps에서 가장 중요한 3가지 동작 : 개발, 빌드, 실행 파일
3. CI / CD 환경에서 빌드를 해야하므로 OpenJDK와 Gradle이 필요
   - 인프라 환경으로 실행 파일을 넘겨주기 위해 배포라는 과정 추가
   - 인프라 환경에는 크게 개발 환경, QA 환경(검증 환경), 운영 환경이 존재
     + 개발 환경 : App이 하나는 아니므로 개발 환경이 있어야 개발한 코드가 다른 App과 문제가 없는지 편하게 테스트 가능 (즉, 여러 개발자들이 같이 사용하는 환경)
     + QA 환경 : 개발자가 아닌 전문 테스트 담당자를 위한 환경 (운영 환경과 동일하게 구성해야 운영 환경에서 App을 배포할 때 발생할 문제를 사전에 파악 가능)
       * 개발 환경에서는 보안 환경 해제 및 스토리지 연결을 구성하지 않고 임시 저장소를 쓰는 경우가 많은데, QA 환경에서는 필요
     + 운영 환경 : 이중화가 필요
       * 운영 환경까지 들어가는 오픈 소스를 선택할 때, 오픈 소스의 이중화 구성이 문제가 없는지 확인이 필수
       * 실제 이중화를 시켜서 App을 올리고, 테스트를 해봐야 하는 것이 운영 환경 구성이 필요

4. CI / CD 환경이 필요한 이유 : Jenkins가 Github에서 소스를 받아 빌드를 하고 배포 하는 역할 수행함으로, 서버가 CI / CD 환경이 되는 것
5. 개발 환경에서의 개발 / 빌드 / 실행 파일이 CI / CD 환경과 인프라 환경으로 나뉠 때, 시스템 구성
   - 기존 구성 : 컨테이너 도입 이전 구성으로 Jenkins를 설치한 뒤 OpenJDK, Gradle로 빌드를 하는 것으로 셋팅
     + 빌드 버튼을 누르면 jar 파일 생성
   - 인프라 환경 : 개발 환경과 운영환경이 존재
     + CI / CD 서버로 넘어와서 배포를 하게 되면, 만들어진 jar 파일을 인프라 환경으로 복사하고, 이 파일을 실행시키라는 명령 전송
     + 이 과정이 Jenkins 배포 스크립트 명령으로 구성되어 있으므로, 서비스가 활성화되면 개발 환경에는 여러 개발자들이, 그리고 운용 환경에는 외부 사용자들이 접속을 할 수 있음

6. 컨테이너 구성
   - 소스 빌드를 하고, 컨테이너 빌드를 통해 DockerHub에 이미지를 적재
   - Kubernetes 인프라 환경에서 kubectl 배포를 하면, Kubernetes가 이미지를 다운 받아 컨테이너 실행
   - 이 컨테이너 안에는 OpenJDK와 실행 파일이 존재 : 컨테이너 배포 때문에 빌드 배포가 복잡해졌지만, 개발하고 빌드해서 실행 파일을 생성
